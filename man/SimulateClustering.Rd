% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulations.R
\name{SimulateClustering}
\alias{SimulateClustering}
\title{Simulation of data with underlying clusters}
\usage{
SimulateClustering(
  n = c(10, 10),
  pk = 10,
  adjacency = NULL,
  theta_xc = NULL,
  nu_xc = 0.1,
  ev_xc = NULL,
  implementation = HugeAdjacency,
  topology = "random",
  nu_within = 0,
  nu_between = NULL,
  v_within = c(0.5, 1),
  v_between = c(0, 0.1),
  v_sign = c(-1, 1),
  continuous = TRUE,
  pd_strategy = "diagonally_dominant",
  ev_xx = NULL,
  scale_ev = TRUE,
  u_list = c(1e-10, 1),
  tol = .Machine$double.eps^0.25,
  scale = TRUE,
  output_matrices = FALSE
)
}
\arguments{
\item{n}{vector of the number of items per cluster in the simulated data. The
total number of items is \code{sum(n)}.}

\item{pk}{vector of the number of attributes in the simulated data.}

\item{adjacency}{optional binary and symmetric adjacency matrix encoding the
conditional independence structure between attributes.}

\item{theta_xc}{optional binary matrix encoding which attributes (columns)
contribute to the clustering structure between which clusters (rows). If
\code{theta_xc=NULL}, variables contributing to the clustering are sampled
with probability \code{nu_xc}.}

\item{nu_xc}{expected proportion of variables contributing to the clustering
over the total number of variables. Only used if \code{theta_xc} is not
provided.}

\item{ev_xc}{vector of marginal expected proportion of explained variance by
each attribute contributing to the clustering.}

\item{implementation}{function for simulation of the graph. By default,
algorithms implemented in \code{\link[huge]{huge.generator}} are used.
Alternatively, a user-defined function can be used. It must take \code{pk},
\code{topology} and \code{nu} as arguments and return a
\code{(sum(pk)*(sum(pk)))} binary and symmetric matrix for which diagonal
entries are all equal to zero. This function is only applied if
\code{theta} is not provided.}

\item{topology}{topology of the simulated graph. If using
\code{implementation=HugeAdjacency}, possible values are listed for the
argument \code{graph} of \code{\link[huge]{huge.generator}}. These are:
"random", "hub", "cluster", "band" and "scale-free".}

\item{nu_within}{expected density (number of edges over the number of node
pairs) of within-group blocks in the graph. If \code{length(pk)=1}, this is
the expected density of the graph. If \code{implementation=HugeAdjacency},
this argument is only used for \code{topology="random"} or
\code{topology="cluster"} (see argument \code{prob} in
\code{\link[huge]{huge.generator}}).}

\item{nu_between}{expected density (number of edges over the number of node
pairs) of between-group blocks in the graph. Similar to \code{nu_within}.
By default, the same density is used for within and between blocks
(\code{nu_within}=\code{nu_between}). Only used if \code{length(pk)>1}.}

\item{v_within}{vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if \code{pd_strategy="min_eigenvalue"}. If \code{continuous=FALSE},
\code{v_within} is the set of possible precision values. If
\code{continuous=TRUE}, \code{v_within} is the range of possible precision
values.}

\item{v_between}{vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. This argument is the same as
\code{v_within} but for off-diagonal blocks. It is only used if
\code{length(pk)>1}.}

\item{v_sign}{vector of possible signs for precision matrix entries. Possible
inputs are: \code{-1} for positive partial correlations, \code{1} for
negative partial correlations, or \code{c(-1, 1)} for both positive and
negative partial correlations.}

\item{continuous}{logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
\code{v_within} (diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=TRUE}) or from proposed values in \code{v_within}
(diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=FALSE}).}

\item{pd_strategy}{method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). If
\code{pd_strategy="diagonally_dominant"}, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. If
\code{pd_strategy="min_eigenvalue"}, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue of the precision matrix with
zeros on the diagonal and a constant u.}

\item{ev_xx}{expected proportion of explained variance by the first Principal
Component (PC1) of a Principal Component Analysis applied on the
predictors. This is the largest eigenvalue of the correlation (if
\code{scale=TRUE}) or covariance (if \code{scale=FALSE}) matrix divided by
the sum of eigenvalues. If \code{ev_xx=NULL} (the default), the constant u
is chosen by maximising the contrast of the correlation matrix.}

\item{scale_ev}{logical indicating if the proportion of explained variance by
PC1 should be computed from the correlation (\code{scale_ev=TRUE}) or
covariance (\code{scale_ev=FALSE}) matrix. If \code{scale_ev=TRUE}, the
correlation matrix is used as parameter of the multivariate normal
distribution.}

\item{u_list}{vector with two numeric values defining the range of values to
explore for constant u.}

\item{tol}{accuracy for the search of parameter u as defined in
\code{\link[stats]{optimise}}.}

\item{scale}{logical indicating if the true mean is zero and true variance is
one for all simulated variables. The observed mean and variance may be
slightly off by chance.}

\item{output_matrices}{logical indicating if the true precision and (partial)
correlation matrices should be included in the output.}
}
\value{
A list with: \item{data}{simulated data with \code{sum(n)}
  observation and \code{sum(pk)} variables} \item{theta}{simulated (true)
  cluster membership.} \item{adjacency}{adjacency matrix of the graph
  encoding the conditional independence structure between variables.}
  \item{theta_xc}{binary vector encoding variables contributing to the
  clustering structure.} \item{ev}{vector of marginal expected proportions of
  explained variance for each variable.} \item{omega}{simulated (true)
  precision matrix. Only returned if \code{output_matrices=TRUE}.}
  \item{phi}{simulated (true) partial correlation matrix. Only returned if
  \code{output_matrices=TRUE}.} \item{sigma}{simulated (true) covariance
  matrix. Only returned if \code{output_matrices=TRUE}.} \item{u}{value of
  the constant u used for the simulation of \code{omega}. Only returned if
  \code{output_matrices=TRUE}.} \item{mu_mixture}{simulated (true)
  cluster-specific means. Only returned if \code{output_matrices=TRUE}.}
}
\description{
Simulates mixture multivariate Normal data with clusters of items (rows)
sharing similar profiles along (a subset of) attributes (columns).
}
\examples{

## Example with 3 clusters

# Data simulation
set.seed(1)
simul <- SimulateClustering(
  n = c(10, 30, 15),
  nu_xc = 1,
  ev_xc = 0.5
)
print(simul)
plot(simul)


## Example with 2 variables contributing to clustering

# Data simulation
set.seed(1)
simul <- SimulateClustering(
  n = c(20, 10, 15), pk = 10,
  theta_xc = c(1, 1, rep(0, 8)),
  ev_xc = 0.8
)
print(simul)
plot(simul)

# Visualisation of the data
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = simul$data,
  colours = c("navy", "white", "red")
)
simul$ev # marginal proportions of explained variance

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta)


## Example with different levels of separation

# Data simulation
set.seed(1)
simul <- SimulateClustering(
  n = c(20, 10, 15), pk = 10,
  theta_xc = c(1, 1, rep(0, 8)),
  ev_xc = c(0.99, 0.5, rep(0, 8))
)
simul$ev

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta)


## Example with correlated contributors

# Data simulation
pk <- 10
adjacency <- matrix(0, pk, pk)
adjacency[1, 2] <- adjacency[2, 1] <- 1
set.seed(1)
simul <- SimulateClustering(
  n = c(200, 100, 150), pk = pk,
  theta_xc = c(1, 1, rep(0, 8)),
  ev_xc = c(0.9, 0.8, rep(0, 8)),
  adjacency = adjacency,
  pd_strategy = "min_eigenvalue",
  v_within = 0.6, v_sign = -1
)

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta)

# Checking marginal proportions of explained variance
mymodel <- lm(simul$data[, 1] ~ as.factor(simul$theta))
summary(mymodel)$r.squared
mymodel <- lm(simul$data[, 2] ~ as.factor(simul$theta))
summary(mymodel)$r.squared

}
\seealso{
\code{\link{MakePositiveDefinite}}

Other simulation functions: 
\code{\link{SimulateAdjacency}()},
\code{\link{SimulateComponents}()},
\code{\link{SimulateGraphical}()},
\code{\link{SimulateRegression}()}
}
\concept{simulation functions}
